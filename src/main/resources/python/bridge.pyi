from typing import Any, Awaitable, Callable, Optional

class BridgeError(Exception): ...
class EntityGoneException(BridgeError): ...

class RaycastResult:
    x: float
    y: float
    z: float
    entity: "Entity" | None
    block: "Block" | None
    start_x: float
    start_y: float
    start_z: float
    yaw: float
    pitch: float
    distance: float
    hit_face: str | None

class EnumValue:
    type: str
    name: str
    def __init__(self, type: str, name: str) -> None: ...
    def __class_getattr__(self, name: str) -> "EnumValue": ...
    @classmethod
    def from_name(cls, name: str) -> "EnumValue": ...

class Event:
    def cancel(self) -> Awaitable[None]: ...
    player: "Player"
    entity: "Entity"
    damager: "Entity" | "Block" | None
    damage: float
    final_damage: float
    damage_cause: Any
    block: "Block"
    world: "World"
    location: "Location"
    item: "Item"
    inventory: "Inventory"
    chunk: "Chunk"
    slot: int

class Entity:
    def __init__(self, uuid: str | None = None) -> None: ...
    @classmethod
    def spawn(cls, entity_type: "EntityType" | str, location: "Location", **kwargs: Any) -> Awaitable["Entity"]: ...
    uuid: str
    type: "EntityType"
    location: "Location"
    world: "World"
    is_projectile: bool
    shooter: "Entity" | "Player" | "Block" | None
    is_tamed: bool
    owner: "Player" | None
    owner_uuid: str | None
    owner_name: str | None
    source: "Entity" | "Player" | None
    def teleport(self, location: "Location") -> Awaitable[None]: ...
    def remove(self) -> Awaitable[None]: ...
    def set_velocity(self, vector: "Vector") -> Awaitable[None]: ...
    velocity: "Vector"
    is_dead: bool
    is_alive: bool
    is_valid: bool
    fire_ticks: int
    def set_fire_ticks(self, ticks: int) -> Awaitable[None]: ...
    def add_passenger(self, entity: "Entity") -> Awaitable[bool]: ...
    def remove_passenger(self, entity: "Entity") -> Awaitable[bool]: ...
    passengers: list["Entity"]
    custom_name: Any
    def set_custom_name(self, name: str) -> Awaitable[None]: ...
    def set_custom_name_visible(self, value: bool) -> Awaitable[None]: ...

class Player(Entity):
    def __init__(self, uuid: str | None = None, name: str | None = None) -> None: ...
    name: str
    uuid: str
    location: "Location"
    world: "World"
    game_mode: "GameMode"
    health: float
    food_level: int
    inventory: "Inventory"
    def send_message(self, message: str) -> Awaitable[None]: ...
    def chat(self, message: str) -> Awaitable[None]: ...
    def kick(self, reason: str = "") -> Awaitable[None]: ...
    def teleport(self, location: "Location") -> Awaitable[None]: ...
    def give_exp(self, amount: int) -> Awaitable[None]: ...
    def add_effect(self, effect: "Effect") -> Awaitable[None]: ...
    def remove_effect(self, effect_type: "EffectType") -> Awaitable[None]: ...
    effects: list["Effect"]
    def set_game_mode(self, mode: "GameMode") -> Awaitable[None]: ...
    scoreboard: "Scoreboard"
    def set_scoreboard(self, scoreboard: "Scoreboard") -> Awaitable[None]: ...
    def has_permission(self, permission: str) -> Awaitable[bool]: ...
    is_op: bool
    def set_op(self, value: bool) -> Awaitable[None]: ...
    def add_permission(self, permission: str, value: bool = True) -> Awaitable[bool]: ...
    def remove_permission(self, permission: str) -> Awaitable[bool]: ...
    permission_groups: list[str]
    primary_group: str | None
    def has_group(self, group: str) -> Awaitable[bool]: ...
    def add_group(self, group: str) -> Awaitable[bool]: ...
    def remove_group(self, group: str) -> Awaitable[bool]: ...
    def play_sound(self, sound: "Sound", volume: float = 1.0, pitch: float = 1.0) -> Awaitable[None]: ...
    def send_action_bar(self, message: str) -> Awaitable[None]: ...
    def send_title(self, title: str, subtitle: str = "", fade_in: int = 10, stay: int = 70, fade_out: int = 20) -> Awaitable[None]: ...
    tab_list_header: str
    tab_list_footer: str
    def set_tab_list_header(self, header: str) -> Awaitable[None]: ...
    def set_tab_list_footer(self, footer: str) -> Awaitable[None]: ...
    def set_tab_list_header_footer(self, header: str = "", footer: str = "") -> Awaitable[None]: ...
    tab_list_name: str
    def set_tab_list_name(self, name: str) -> Awaitable[None]: ...
    def set_health(self, health: float) -> Awaitable[None]: ...
    def set_food_level(self, level: int) -> Awaitable[None]: ...
    level: int
    def set_level(self, level: int) -> Awaitable[None]: ...
    exp: float
    def set_exp(self, exp: float) -> Awaitable[None]: ...
    is_flying: bool
    def set_flying(self, value: bool) -> Awaitable[None]: ...
    is_sneaking: bool
    def set_sneaking(self, value: bool) -> Awaitable[None]: ...
    is_sprinting: bool
    def set_sprinting(self, value: bool) -> Awaitable[None]: ...
    def set_walk_speed(self, speed: float) -> Awaitable[None]: ...
    def set_fly_speed(self, speed: float) -> Awaitable[None]: ...

class EntityType(EnumValue):
    def __class_getattr__(self, name: str) -> "EntityType": ...

class World:
    def __init__(self, name: str | None = None) -> None: ...
    name: str
    uuid: str
    environment: Any
    entities: list["Entity"]
    def block_at(self, x: int, y: int, z: int) -> Awaitable["Block"]: ...
    def spawn_entity(self, location: "Location", entity_type: "EntityType" | str, **kwargs: Any) -> Awaitable["Entity"]: ...
    def chunk_at(self, x: int, z: int) -> Awaitable["Chunk"]: ...
    def spawn(self, location: "Location", entity_cls: type | "EntityType" | str, **kwargs: Any) -> Awaitable["Entity"]: ...
    def set_time(self, time: int) -> Awaitable[None]: ...
    time: int
    def set_difficulty(self, difficulty: "Difficulty") -> Awaitable[None]: ...
    difficulty: "Difficulty"
    players: list["Player"]
    def spawn_particle(self, particle: "Particle", location: "Location", count: int = 1, offset_x: float = 0, offset_y: float = 0, offset_z: float = 0, extra: float = 0) -> Awaitable[None]: ...
    def play_sound(self, location: "Location", sound: "Sound", volume: float = 1.0, pitch: float = 1.0) -> Awaitable[None]: ...
    def strike_lightning(self, location: "Location") -> Awaitable["Entity"]: ...
    def strike_lightning_effect(self, location: "Location") -> Awaitable[None]: ...
    spawn_location: "Location"
    def set_spawn_location(self, location: "Location") -> Awaitable[None]: ...
    full_time: int
    def set_full_time(self, time: int) -> Awaitable[None]: ...
    has_storm: bool
    def set_storm(self, value: bool) -> Awaitable[None]: ...
    is_thundering: bool
    def set_thundering(self, value: bool) -> Awaitable[None]: ...
    weather_duration: int
    def set_weather_duration(self, ticks: int) -> Awaitable[None]: ...
    thunder_duration: int
    def set_thunder_duration(self, ticks: int) -> Awaitable[None]: ...
    # Region utilities
    def set_block(self, x: int, y: int, z: int, material: "Material" | str, apply_physics: bool = False) -> Awaitable[int]: ...
    def fill(self, pos1: "Location" | tuple[int,int,int] | "Vector", pos2: "Location" | tuple[int,int,int] | "Vector", material: "Material" | str, apply_physics: bool = False) -> Awaitable[int]: ...
    def replace(self, pos1: "Location" | tuple[int,int,int] | "Vector", pos2: "Location" | tuple[int,int,int] | "Vector", from_material: "Material" | str, to_material: "Material" | str) -> Awaitable[int]: ...
    def fill_sphere(self, center: "Location" | tuple[int,int,int] | "Vector", radius: float, material: "Material" | str, hollow: bool = False) -> Awaitable[int]: ...
    def fill_cylinder(self, center: "Location" | tuple[int,int,int] | "Vector", radius: float, height: int, material: "Material" | str, hollow: bool = False) -> Awaitable[int]: ...
    def fill_line(self, start: "Location" | tuple[int,int,int] | "Vector", end: "Location" | tuple[int,int,int] | "Vector", material: "Material" | str) -> Awaitable[int]: ...
    # Particle shape utilities
    def particle_line(self, start: "Location" | tuple[int,int,int] | "Vector", end: "Location" | tuple[int,int,int] | "Vector", particle: "Particle" | str, density: float = 4.0, offset_x: float = 0, offset_y: float = 0, offset_z: float = 0, extra: float = 0) -> Awaitable[int]: ...
    def particle_sphere(self, center: "Location" | tuple[int,int,int] | "Vector", radius: float, particle: "Particle" | str, density: float = 4.0, hollow: bool = True, offset_x: float = 0, offset_y: float = 0, offset_z: float = 0, extra: float = 0) -> Awaitable[int]: ...
    def particle_cube(self, pos1: "Location" | tuple[int,int,int] | "Vector", pos2: "Location" | tuple[int,int,int] | "Vector", particle: "Particle" | str, density: float = 4.0, hollow: bool = True, offset_x: float = 0, offset_y: float = 0, offset_z: float = 0, extra: float = 0) -> Awaitable[int]: ...
    def particle_ring(self, center: "Location" | tuple[int,int,int] | "Vector", radius: float, particle: "Particle" | str, density: float = 4.0, offset_x: float = 0, offset_y: float = 0, offset_z: float = 0, extra: float = 0) -> Awaitable[int]: ...
    # Entity spawn helpers
    def spawn_at_player(self, player: "Player", entity_type: "EntityType" | str, offset: "Vector" | tuple[int,int,int] | None = None, **kwargs: Any) -> Awaitable["Entity"]: ...
    def spawn_projectile(self, shooter: "Entity", entity_type: "EntityType" | str, velocity: "Vector" | tuple[int,int,int] | None = None, **kwargs: Any) -> Awaitable["Entity"]: ...
    def spawn_with_nbt(self, location: "Location", entity_type: "EntityType" | str, nbt: str, **kwargs: Any) -> Awaitable["Entity"]: ...

class Dimension: ...

class Location:
    def __init__(self, x: float = 0.0, y: float = 0.0, z: float = 0.0, world: "World" | str | None = None, yaw: float = 0.0, pitch: float = 0.0) -> None: ...

    x: float
    y: float
    z: float
    yaw: float
    pitch: float
    world: "World"
    def add(self, x: float, y: float, z: float) -> "Location": ...
    def clone(self) -> "Location": ...
    def distance(self, other: "Location") -> float: ...
    def distance_squared(self, other: "Location") -> float: ...

class Block:
    def __init__(self, world: "World" | str | None = None, x: int | None = None, y: int | None = None, z: int | None = None, material: "Material" | str | None = None) -> None: ...
    @classmethod
    def create(cls, location: "Location", material: "Material" | str) -> Awaitable["Block"]: ...
    x: int
    y: int
    z: int
    type: "Material"
    location: "Location"
    world: "World"
    def break_naturally(self) -> Awaitable[None]: ...
    def set_type(self, material: "Material") -> Awaitable[None]: ...
    is_solid: bool
    data: Any
    def set_data(self, data: Any) -> Awaitable[None]: ...
    light_level: int
    biome: "Biome"
    def set_biome(self, biome: "Biome") -> Awaitable[None]: ...

class Chunk:
    def __init__(self, world: "World" | str | None = None, x: int | None = None, z: int | None = None) -> None: ...
    x: int
    z: int
    world: "World"
    def load(self) -> Awaitable[bool]: ...
    def unload(self) -> Awaitable[bool]: ...
    is_loaded: bool

class Inventory:
    def __init__(self, size: int = 9, title: str = "", contents: list["Item"] | None = None) -> None: ...
    size: int
    contents: list["Item"]
    holder: Any
    title: str
    def open(self, player: "Player") -> Awaitable[Any]: ...
    def add_item(self, item: "Item") -> Awaitable[Any]: ...
    def remove_item(self, item: "Item") -> Awaitable[Any]: ...
    def clear(self) -> Awaitable[None]: ...
    def close(self, player: "Player" | None = None) -> Awaitable[Any]: ...
    first_empty: int
    def get_item(self, slot: int) -> Awaitable["Item"]: ...
    def set_item(self, slot: int, item: "Item") -> Awaitable[None]: ...
    def contains(self, material: "Material", amount: int = 1) -> Awaitable[bool]: ...

class Item:
    def __init__(self, material: "Material" | str | None = None, amount: int = 1, name: str | None = None, lore: list[str] | None = None, custom_model_data: int | None = None, attributes: list[dict[str, Any]] | None = None, nbt: dict[str, Any] | None = None) -> None: ...
    @classmethod
    def drop(cls, material: "Material" | str, location: "Location", amount: int = 1, **kwargs: Any) -> Awaitable["Entity"]: ...
    @classmethod
    def give(cls, player: "Player", material: "Material" | str, amount: int = 1, **kwargs: Any) -> Awaitable[Any]: ...
    type: "Material"
    amount: int
    name: str | None
    lore: list[str]
    custom_model_data: int | None
    attributes: list[dict[str, Any]]
    nbt: dict[str, Any]
    def set_amount(self, value: int) -> Awaitable[None]: ...
    def set_name(self, name: str) -> Awaitable[None]: ...
    def set_lore(self, lore: list[str]) -> Awaitable[None]: ...
    def set_custom_model_data(self, value: int) -> Awaitable[None]: ...
    def set_attributes(self, attributes: list[dict[str, Any]]) -> Awaitable[None]: ...
    def set_nbt(self, nbt: dict[str, Any]) -> Awaitable[None]: ...
    def clone(self) -> Awaitable["Item"]: ...
    def is_similar(self, other: "Item") -> Awaitable[bool]: ...
    max_stack_size: int

class ItemBuilder:
    def __init__(self, material: "Material" | str) -> None: ...
    def amount(self, n: int) -> "ItemBuilder": ...
    def name(self, n: str) -> "ItemBuilder": ...
    def lore(self, *lines: str) -> "ItemBuilder": ...
    def add_lore(self, line: str) -> "ItemBuilder": ...
    def enchant(self, enchantment: str, level: int = 1) -> "ItemBuilder": ...
    def unbreakable(self, value: bool = True) -> "ItemBuilder": ...
    def glow(self, value: bool = True) -> "ItemBuilder": ...
    def custom_model_data(self, value: int) -> "ItemBuilder": ...
    def attributes(self, attrs: list[dict[str, Any]]) -> "ItemBuilder": ...
    def add_attribute(self, attribute: str, amount: float, operation: str = "ADD_NUMBER") -> "ItemBuilder": ...
    def nbt(self, data: dict[str, Any]) -> "ItemBuilder": ...
    def flag(self, *flags: str) -> "ItemBuilder": ...
    def build(self) -> "Item": ...
    @classmethod
    def from_item(cls, item: "Item") -> "ItemBuilder": ...

class Material(EnumValue):
    def __class_getattr__(self, name: str) -> "Material": ...

class Biome(EnumValue):
    def __class_getattr__(self, name: str) -> "Biome": ...

class Effect:
    @classmethod
    def apply(cls, player: "Player", effect_type: "EffectType" | str | None = None, duration: int = 0, amplifier: int = 0, ambient: bool = False, particles: bool = True, icon: bool = True) -> Awaitable[Any]: ...
    def __init__(self, effect_type: "EffectType" | str | None = None, duration: int = 0, amplifier: int = 0, ambient: bool = False, particles: bool = True, icon: bool = True) -> None: ...
    type: "EffectType"
    duration: int
    amplifier: int
    ambient: bool
    particles: bool
    icon: bool
    def with_duration(self, duration: int) -> Awaitable["Effect"]: ...
    def with_amplifier(self, amplifier: int) -> Awaitable["Effect"]: ...

class EffectType(EnumValue):
    def __class_getattr__(self, name: str) -> "EffectType": ...

class AttributeType(EnumValue):
    def __class_getattr__(self, name: str) -> "AttributeType": ...

class Attribute:
    @classmethod
    def apply(cls, player: "Player", attribute_type: "AttributeType" | str, base_value: float) -> Awaitable[Any]: ...
    attribute_type: "AttributeType"
    value: float
    base_value: float
    def set_base_value(self, value: float) -> Awaitable[None]: ...

class GameMode(EnumValue):
    def __class_getattr__(self, name: str) -> "GameMode": ...

class Sound(EnumValue):
    def __class_getattr__(self, name: str) -> "Sound": ...

class Particle(EnumValue):
    def __class_getattr__(self, name: str) -> "Particle": ...

class Difficulty(EnumValue):
    def __class_getattr__(self, name: str) -> "Difficulty": ...

class Vector:
    def __init__(self, x: float = 0.0, y: float = 0.0, z: float = 0.0) -> None: ...
    x: float
    y: float
    z: float

class BarColor(EnumValue):
    def __class_getattr__(self, name: str) -> "BarColor": ...

class BarStyle(EnumValue):
    def __class_getattr__(self, name: str) -> "BarStyle": ...

class BossBar:
    @classmethod
    def create(cls, title: str, color: BarColor | EnumValue | None = None, style: BarStyle | EnumValue | None = None, players: list["Player"] | None = None) -> "BossBar": ...
    def add_player(self, player: "Player") -> Awaitable[None]: ...
    def remove_player(self, player: "Player") -> Awaitable[None]: ...
    title: str
    def set_title(self, title: str) -> Awaitable[None]: ...
    progress: float
    def set_progress(self, value: float) -> Awaitable[None]: ...
    color: "BarColor"
    def set_color(self, color: "BarColor") -> Awaitable[None]: ...
    style: "BarStyle"
    def set_style(self, style: "BarStyle") -> Awaitable[None]: ...
    visible: bool
    def set_visible(self, value: bool) -> Awaitable[None]: ...

class Scoreboard:
    @classmethod
    def create(cls) -> "Scoreboard": ...
    def register_objective(self, name: str, criteria: str, display_name: str = "") -> "Objective": ...
    def get_team(self, name: str) -> "Team": ...
    def register_team(self, name: str) -> "Team": ...
    def get_objective(self, name: str) -> "Objective": ...
    objectives: list["Objective"]
    teams: list["Team"]
    def clear_slot(self, slot: Any) -> Awaitable[None]: ...

class Team:
    @classmethod
    def create(cls, name: str, scoreboard: "Scoreboard" | None = None) -> "Team": ...
    def add_entry(self, entry: str) -> Awaitable[None]: ...
    def remove_entry(self, entry: str) -> Awaitable[None]: ...
    def set_prefix(self, prefix: str) -> Awaitable[None]: ...
    def set_suffix(self, suffix: str) -> Awaitable[None]: ...
    color: Any
    def set_color(self, color: Any) -> Awaitable[None]: ...
    entries: set[str]

class Objective:
    @classmethod
    def create(cls, name: str, criteria: str, display_name: str = "", scoreboard: "Scoreboard" | None = None) -> "Objective": ...
    def set_display_name(self, name: str) -> Awaitable[None]: ...
    def get_score(self, entry: str) -> Any: ...
    name: str
    criteria: str
    display_slot: Any
    def set_display_slot(self, slot: Any) -> Awaitable[None]: ...

class Sidebar:
    MAX_LINES: int
    def __init__(self, title: str = "") -> None: ...
    def __setitem__(self, slot: int, text: str) -> None: ...
    def __getitem__(self, slot: int) -> str: ...
    def __delitem__(self, slot: int) -> None: ...
    def show(self, player: "Player") -> None: ...
    title: str

class Hologram:
    def __init__(self, location: "Location", *lines: str, billboard: str = "CENTER") -> None: ...
    def __setitem__(self, index: int, text: str) -> None: ...
    def __getitem__(self, index: int) -> str: ...
    def __delitem__(self, index: int) -> None: ...
    def __len__(self) -> int: ...
    def append(self, text: str) -> None: ...
    def teleport(self, location: "Location") -> None: ...
    def remove(self) -> None: ...
    billboard: str
    see_through: bool
    shadowed: bool
    alignment: str
    line_width: int
    background: int | None

class MenuItem:
    item: "Item"
    on_click: Callable[["Player", "Event"], Any] | None
    def __init__(self, item: "Item" | str, on_click: Callable[["Player", "Event"], Any] | None = None) -> None: ...

class Menu:
    def __init__(self, title: str = "", rows: int = 3) -> None: ...
    def __setitem__(self, slot: int, menu_item: "MenuItem") -> None: ...
    def __getitem__(self, slot: int) -> "MenuItem" | None: ...
    def __delitem__(self, slot: int) -> None: ...
    def fill_border(self, item: "Item") -> None: ...
    def open(self, player: "Player") -> None: ...
    title: str
    rows: int

class Cooldown:
    seconds: float
    on_expire: Callable[["Player"], Any] | None
    def __init__(self, seconds: float = 1.0, on_expire: Callable[["Player"], Any] | None = None) -> None: ...
    def check(self, player: "Player") -> bool: ...
    def remaining(self, player: "Player") -> float: ...
    def reset(self, player: "Player") -> None: ...

class ActionBarDisplay:
    def __init__(self) -> None: ...
    def __setitem__(self, player: "Player", text: str) -> None: ...
    def __getitem__(self, player: "Player") -> str: ...
    def __delitem__(self, player: "Player") -> None: ...

class BossBarDisplay:
    def __init__(self, title: str = "", color: str = "PINK", style: str = "SOLID") -> None: ...
    def show(self, player: "Player") -> None: ...
    def hide(self, player: "Player") -> None: ...
    text: str
    color: str
    style: str
    value: float
    max: float
    progress: float
    visible: bool
    def link_cooldown(self, cooldown: "Cooldown", player: "Player") -> None: ...

class BlockDisplay:
    def __init__(self, location: "Location", block_type: str, billboard: str = "FIXED") -> None: ...
    def teleport(self, location: "Location") -> None: ...
    def remove(self) -> None: ...
    billboard: str

class ItemDisplay:
    def __init__(self, location: "Location", item: "Item" | str, billboard: str = "FIXED") -> None: ...
    def teleport(self, location: "Location") -> None: ...
    def remove(self) -> None: ...
    billboard: str

class ImageDisplay:
    def __init__(self, location: "Location", image_path: str, pixel_size: float = ..., dual_sided: bool = False, dual_side_mode: str = "mirror") -> None: ...
    def teleport(self, location: "Location") -> None: ...
    def remove(self) -> None: ...

class Advancement:
    @classmethod
    def grant(cls, player: "Player", key: str) -> Awaitable["AdvancementProgress"]: ...
    @classmethod
    def revoke(cls, player: "Player", key: str) -> Awaitable["AdvancementProgress"]: ...
    key: Any

class AdvancementProgress:
    is_done: bool
    def award_criteria(self, name: str) -> Awaitable[bool]: ...
    def revoke_criteria(self, name: str) -> Awaitable[bool]: ...
    remaining_criteria: set[str]
    awarded_criteria: set[str]

class Potion:
    @classmethod
    def apply(cls, player: "Player", effect_type: "EffectType" | str | None = None, duration: int = 0, amplifier: int = 0, ambient: bool = False, particles: bool = True, icon: bool = True) -> Awaitable[Any]: ...
    type: Any
    level: int

class Config:
    def __init__(self, name: str | None = None, defaults: dict[str, Any] | None = None) -> None: ...
    def reload(self) -> None: ...
    def save(self) -> None: ...
    def get(self, path: str, default: Any = None) -> Any: ...
    def get_int(self, path: str, default: int = 0) -> int: ...
    def get_float(self, path: str, default: float = 0.0) -> float: ...
    def get_bool(self, path: str, default: bool = False) -> bool: ...
    def get_list(self, path: str, default: list[Any] | None = None) -> list[Any]: ...
    def set(self, path: str, value: Any) -> None: ...
    def delete(self, path: str) -> bool: ...
    def __getitem__(self, key: str) -> Any: ...
    def __setitem__(self, key: str, value: Any) -> None: ...
    def __contains__(self, key: str) -> bool: ...
    data: dict[str, Any]
    path: str

class Server:
    def broadcast(self, message: str) -> Awaitable[None]: ...
    def execute(self, command: str) -> Awaitable[bool]: ...
    players: list["Player"]
    worlds: list["World"]
    def world(self, name: str) -> Awaitable["World"]: ...
    scoreboard_manager: Any
    def create_boss_bar(self, title: str, color: "BarColor", style: "BarStyle") -> Awaitable["BossBar"]: ...
    boss_bars: list["BossBar"]
    def get_advancement(self, key: str) -> Awaitable["Advancement"]: ...
    plugin_manager: Any
    scheduler: Any
    def wait(self, ticks: int = 1, after: Callable[[], Any] | None = None) -> Awaitable[None]: ...
    def frame(self) -> Any: ...
    def atomic(self) -> Any: ...
    def flush(self) -> Awaitable[None]: ...
    name: str
    version: str
    motd: str
    max_players: int
    tps: list[float]
    mspt: float
    last_tick_time: float
    queue_len: int

class Chat:
    def broadcast(self, message: str) -> Awaitable[None]: ...

class Reflect:
    def clazz(self, name: str) -> Awaitable[Any]: ...

server: Server
chat: Chat
reflect: Reflect


def event(func: Optional[Callable[[Event], Optional[Any]]] = None, *, once_per_tick: bool = False, priority: str = "NORMAL", throttle_ms: int = 0) -> Callable[..., Any]: ...

def task(func: Optional[Callable[[], Any]] = None, *, interval: int = 20, delay: int = 0) -> Callable[..., Any]: ...

def command(description: Optional[str] = None, *, name: Optional[str] = None, permission: Optional[str] = None) -> Callable[..., Any]: ...

def raycast(
    world: World | str,
    start: Vector|tuple[float,float,float],
    direction: tuple[float,float],
    max_distance: float = 64.0,
    ray_size: float = 0.2,
    include_entities: bool = True,
    include_blocks: bool = True,
    ignore_passable: bool = True,
) -> Awaitable[RaycastResult | None]: ...
